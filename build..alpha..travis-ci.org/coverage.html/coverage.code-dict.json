{"/home/travis/build/npmtest/node-npmtest-npm-check-updates/test.js":"/* istanbul instrument in package npmtest_npm_check_updates */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - init-before\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        switch (local.modeJs) {\n        // re-init local from window.local\n        case 'browser':\n            local = local.global.utility2.objectSetDefault(\n                local.global.utility2_rollup || local.global.local,\n                local.global.utility2\n            );\n            break;\n        // re-init local from example.js\n        case 'node':\n            local = (local.global.utility2_rollup || require('utility2'))\n                .requireReadme();\n            break;\n        }\n        // export local\n        local.global.local = local;\n    }());\n\n\n\n    // run shared js-env code - function\n    (function () {\n        return;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // run browser js-env code - function\n    case 'browser':\n        break;\n\n\n\n    // run node js-env code - function\n    case 'node':\n        break;\n    }\n\n\n\n    // run shared js-env code - init-after\n    (function () {\n        return;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // run browser js-env code - init-after\n    case 'browser':\n        local.testCase_browser_nullCase = local.testCase_browser_nullCase || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test browsers's null-case handling-behavior-behavior\n         */\n            onError(null, options);\n        };\n\n        // run tests\n        local.nop(local.modeTest &&\n            document.querySelector('#testRunButton1') &&\n            document.querySelector('#testRunButton1').click());\n        break;\n\n\n\n    // run node js-env code - init-after\n    /* istanbul ignore next */\n    case 'node':\n        local.testCase_buildApidoc_default = local.testCase_buildApidoc_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildApidoc's default handling-behavior-behavior\n         */\n            options = { modulePathList: module.paths };\n            local.buildApidoc(options, onError);\n        };\n\n        local.testCase_buildApp_default = local.testCase_buildApp_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildApp's default handling-behavior-behavior\n         */\n            local.testCase_buildReadme_default(options, local.onErrorThrow);\n            local.testCase_buildLib_default(options, local.onErrorThrow);\n            local.testCase_buildTest_default(options, local.onErrorThrow);\n            local.testCase_buildCustomOrg_default(options, local.onErrorThrow);\n            options = [];\n            local.buildApp(options, onError);\n        };\n\n        local.testCase_buildCustomOrg_default = local.testCase_buildCustomOrg_default ||\n            function (options, onError) {\n            /*\n             * this function will test buildCustomOrg's default handling-behavior\n             */\n                options = {};\n                local.buildCustomOrg(options, onError);\n            };\n\n        local.testCase_buildLib_default = local.testCase_buildLib_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildLib's default handling-behavior\n         */\n            options = {};\n            local.buildLib(options, onError);\n        };\n\n        local.testCase_buildReadme_default = local.testCase_buildReadme_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildReadme's default handling-behavior-behavior\n         */\n            options = {};\n            local.buildReadme(options, onError);\n        };\n\n        local.testCase_buildTest_default = local.testCase_buildTest_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildTest's default handling-behavior\n         */\n            options = {};\n            local.buildTest(options, onError);\n        };\n\n        local.testCase_webpage_default = local.testCase_webpage_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test webpage's default handling-behavior\n         */\n            options = { modeCoverageMerge: true, url: local.serverLocalHost + '?modeTest=1' };\n            local.browserTest(options, onError);\n        };\n\n        // run test-server\n        local.testRunServer(local);\n        break;\n    }\n}());\n","/home/travis/build/npmtest/node-npmtest-npm-check-updates/lib.npmtest_npm_check_updates.js":"/* istanbul instrument in package npmtest_npm_check_updates */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - init-before\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        // init utility2_rollup\n        local = local.global.utility2_rollup || local;\n        // init lib\n        local.local = local.npmtest_npm_check_updates = local;\n        // init exports\n        if (local.modeJs === 'browser') {\n            local.global.utility2_npmtest_npm_check_updates = local;\n        } else {\n            module.exports = local;\n            module.exports.__dirname = __dirname;\n            module.exports.module = module;\n        }\n    }());\n}());\n","/home/travis/build/npmtest/node-npmtest-npm-check-updates/example.js":"/*\nexample.js\n\nquickstart example\n\ninstruction\n    1. save this script as example.js\n    2. run the shell command:\n        $ npm install npmtest-npm-check-updates && PORT=8081 node example.js\n    3. play with the browser-demo on http://127.0.0.1:8081\n*/\n\n\n\n/* istanbul instrument in package npmtest_npm_check_updates */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - init-before\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        // init utility2_rollup\n        local = local.global.utility2_rollup || (local.modeJs === 'browser'\n            ? local.global.utility2_npmtest_npm_check_updates\n            : global.utility2_moduleExports);\n        // export local\n        local.global.local = local;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // init-after\n    // run browser js-env code - init-after\n    /* istanbul ignore next */\n    case 'browser':\n        local.testRunBrowser = function (event) {\n            if (!event || (event &&\n                    event.currentTarget &&\n                    event.currentTarget.className &&\n                    event.currentTarget.className.includes &&\n                    event.currentTarget.className.includes('onreset'))) {\n                // reset output\n                Array.from(\n                    document.querySelectorAll('body > .resettable')\n                ).forEach(function (element) {\n                    switch (element.tagName) {\n                    case 'INPUT':\n                    case 'TEXTAREA':\n                        element.value = '';\n                        break;\n                    default:\n                        element.textContent = '';\n                    }\n                });\n            }\n            switch (event && event.currentTarget && event.currentTarget.id) {\n            case 'testRunButton1':\n                // show tests\n                if (document.querySelector('#testReportDiv1').style.display === 'none') {\n                    document.querySelector('#testReportDiv1').style.display = 'block';\n                    document.querySelector('#testRunButton1').textContent =\n                        'hide internal test';\n                    local.modeTest = true;\n                    local.testRunDefault(local);\n                // hide tests\n                } else {\n                    document.querySelector('#testReportDiv1').style.display = 'none';\n                    document.querySelector('#testRunButton1').textContent = 'run internal test';\n                }\n                break;\n            // custom-case\n            default:\n                break;\n            }\n            if (document.querySelector('#inputTextareaEval1') && (!event || (event &&\n                    event.currentTarget &&\n                    event.currentTarget.className &&\n                    event.currentTarget.className.includes &&\n                    event.currentTarget.className.includes('oneval')))) {\n                // try to eval input-code\n                try {\n                    /*jslint evil: true*/\n                    eval(document.querySelector('#inputTextareaEval1').value);\n                } catch (errorCaught) {\n                    console.error(errorCaught);\n                }\n            }\n        };\n        // log stderr and stdout to #outputTextareaStdout1\n        ['error', 'log'].forEach(function (key) {\n            console[key + '_original'] = console[key];\n            console[key] = function () {\n                var element;\n                console[key + '_original'].apply(console, arguments);\n                element = document.querySelector('#outputTextareaStdout1');\n                if (!element) {\n                    return;\n                }\n                // append text to #outputTextareaStdout1\n                element.value += Array.from(arguments).map(function (arg) {\n                    return typeof arg === 'string'\n                        ? arg\n                        : JSON.stringify(arg, null, 4);\n                }).join(' ') + '\\n';\n                // scroll textarea to bottom\n                element.scrollTop = element.scrollHeight;\n            };\n        });\n        // init event-handling\n        ['change', 'click', 'keyup'].forEach(function (event) {\n            Array.from(document.querySelectorAll('.on' + event)).forEach(function (element) {\n                element.addEventListener(event, local.testRunBrowser);\n            });\n        });\n        // run tests\n        local.testRunBrowser();\n        break;\n\n\n\n    // run node js-env code - init-after\n    /* istanbul ignore next */\n    case 'node':\n        // export local\n        module.exports = local;\n        // require modules\n        local.fs = require('fs');\n        local.http = require('http');\n        local.url = require('url');\n        // init assets\n        local.assetsDict = local.assetsDict || {};\n        /* jslint-ignore-begin */\n        local.assetsDict['/assets.index.template.html'] = '\\\n<!doctype html>\\n\\\n<html lang=\"en\">\\n\\\n<head>\\n\\\n<meta charset=\"UTF-8\">\\n\\\n<meta name=\"viewport\" content=\"width=device-width, initial-scale=1\">\\n\\\n<title>{{env.npm_package_name}} (v{{env.npm_package_version}})</title>\\n\\\n<style>\\n\\\n/*csslint\\n\\\n    box-sizing: false,\\n\\\n    universal-selector: false\\n\\\n*/\\n\\\n* {\\n\\\n    box-sizing: border-box;\\n\\\n}\\n\\\nbody {\\n\\\n    background: #dde;\\n\\\n    font-family: Arial, Helvetica, sans-serif;\\n\\\n    margin: 2rem;\\n\\\n}\\n\\\nbody > * {\\n\\\n    margin-bottom: 1rem;\\n\\\n}\\n\\\n.utility2FooterDiv {\\n\\\n    margin-top: 20px;\\n\\\n    text-align: center;\\n\\\n}\\n\\\n</style>\\n\\\n<style>\\n\\\n/*csslint\\n\\\n*/\\n\\\ntextarea {\\n\\\n    font-family: monospace;\\n\\\n    height: 10rem;\\n\\\n    width: 100%;\\n\\\n}\\n\\\ntextarea[readonly] {\\n\\\n    background: #ddd;\\n\\\n}\\n\\\n</style>\\n\\\n</head>\\n\\\n<body>\\n\\\n<!-- utility2-comment\\n\\\n<div id=\"ajaxProgressDiv1\" style=\"background: #d00; height: 2px; left: 0; margin: 0; padding: 0; position: fixed; top: 0; transition: background 0.5s, width 1.5s; width: 25%;\"></div>\\n\\\nutility2-comment -->\\n\\\n<h1>\\n\\\n<!-- utility2-comment\\n\\\n    <a\\n\\\n        {{#if env.npm_package_homepage}}\\n\\\n        href=\"{{env.npm_package_homepage}}\"\\n\\\n        {{/if env.npm_package_homepage}}\\n\\\n        target=\"_blank\"\\n\\\n    >\\n\\\nutility2-comment -->\\n\\\n        {{env.npm_package_name}} (v{{env.npm_package_version}})\\n\\\n<!-- utility2-comment\\n\\\n    </a>\\n\\\nutility2-comment -->\\n\\\n</h1>\\n\\\n<h3>{{env.npm_package_description}}</h3>\\n\\\n<!-- utility2-comment\\n\\\n<h4><a download href=\"assets.app.js\">download standalone app</a></h4>\\n\\\n<button class=\"onclick onreset\" id=\"testRunButton1\">run internal test</button><br>\\n\\\n<div id=\"testReportDiv1\" style=\"display: none;\"></div>\\n\\\nutility2-comment -->\\n\\\n\\n\\\n\\n\\\n\\n\\\n<label>stderr and stdout</label>\\n\\\n<textarea class=\"resettable\" id=\"outputTextareaStdout1\" readonly></textarea>\\n\\\n<!-- utility2-comment\\n\\\n{{#if isRollup}}\\n\\\n<script src=\"assets.app.js\"></script>\\n\\\n{{#unless isRollup}}\\n\\\nutility2-comment -->\\n\\\n<script src=\"assets.utility2.rollup.js\"></script>\\n\\\n<script src=\"jsonp.utility2._stateInit?callback=window.utility2._stateInit\"></script>\\n\\\n<script src=\"assets.npmtest_npm_check_updates.rollup.js\"></script>\\n\\\n<script src=\"assets.example.js\"></script>\\n\\\n<script src=\"assets.test.js\"></script>\\n\\\n<!-- utility2-comment\\n\\\n{{/if isRollup}}\\n\\\nutility2-comment -->\\n\\\n<div class=\"utility2FooterDiv\">\\n\\\n    [ this app was created with\\n\\\n    <a href=\"https://github.com/kaizhu256/node-utility2\" target=\"_blank\">utility2</a>\\n\\\n    ]\\n\\\n</div>\\n\\\n</body>\\n\\\n</html>\\n\\\n';\n        /* jslint-ignore-end */\n        if (local.templateRender) {\n            local.assetsDict['/'] = local.templateRender(\n                local.assetsDict['/assets.index.template.html'],\n                {\n                    env: local.objectSetDefault(local.env, {\n                        npm_package_description: 'the greatest app in the world!',\n                        npm_package_name: 'my-app',\n                        npm_package_nameAlias: 'my_app',\n                        npm_package_version: '0.0.1'\n                    })\n                }\n            );\n        } else {\n            local.assetsDict['/'] = local.assetsDict['/assets.index.template.html']\n                .replace((/\\{\\{env\\.(\\w+?)\\}\\}/g), function (match0, match1) {\n                    // jslint-hack\n                    String(match0);\n                    switch (match1) {\n                    case 'npm_package_description':\n                        return 'the greatest app in the world!';\n                    case 'npm_package_name':\n                        return 'my-app';\n                    case 'npm_package_nameAlias':\n                        return 'my_app';\n                    case 'npm_package_version':\n                        return '0.0.1';\n                    }\n                });\n        }\n        // run the cli\n        if (local.global.utility2_rollup || module !== require.main) {\n            break;\n        }\n        local.assetsDict['/assets.example.js'] =\n            local.assetsDict['/assets.example.js'] ||\n            local.fs.readFileSync(__filename, 'utf8');\n        // bug-workaround - long $npm_package_buildCustomOrg\n        /* jslint-ignore-begin */\n        local.assetsDict['/assets.npmtest_npm_check_updates.rollup.js'] =\n            local.assetsDict['/assets.npmtest_npm_check_updates.rollup.js'] ||\n            local.fs.readFileSync(\n                local.npmtest_npm_check_updates.__dirname + '/lib.npmtest_npm_check_updates.js',\n                'utf8'\n            ).replace((/^#!/), '//');\n        /* jslint-ignore-end */\n        local.assetsDict['/favicon.ico'] = local.assetsDict['/favicon.ico'] || '';\n        // if $npm_config_timeout_exit exists,\n        // then exit this process after $npm_config_timeout_exit ms\n        if (Number(process.env.npm_config_timeout_exit)) {\n            setTimeout(process.exit, Number(process.env.npm_config_timeout_exit));\n        }\n        // start server\n        if (local.global.utility2_serverHttp1) {\n            break;\n        }\n        process.env.PORT = process.env.PORT || '8081';\n        console.error('server starting on port ' + process.env.PORT);\n        local.http.createServer(function (request, response) {\n            request.urlParsed = local.url.parse(request.url);\n            if (local.assetsDict[request.urlParsed.pathname] !== undefined) {\n                response.end(local.assetsDict[request.urlParsed.pathname]);\n                return;\n            }\n            response.statusCode = 404;\n            response.end();\n        }).listen(process.env.PORT);\n        break;\n    }\n}());\n","/home/travis/build/npmtest/node-npmtest-npm-check-updates/node_modules/npm-check-updates/lib/npm-check-updates.js":"//\n// Dependencies\n//\n\nvar cint = require('cint');\nvar path = require('path');\nvar findUp = require('find-up');\nvar _ = require('lodash');\nvar Promise = require('bluebird');\nvar getstdin = require('get-stdin');\nvar Table = require('cli-table');\nvar chalk = require('chalk');\nvar fs = Promise.promisifyAll(require('fs'));\nvar vm = require('./versionmanager');\nvar versionUtil = require('./version-util');\nvar jph = require('json-parse-helpfulerror');\n\n// maps package managers to package file names\nvar packageFileNames = {\n    npm: 'package.json',\n    bower: 'bower.json'\n};\n\n// maps string levels to numeric levels\nvar logLevels = {\n    silent: 0,\n    error: 1,\n    minimal: 2,\n    warn: 3,\n    info: 4,\n    verbose: 5,\n    silly: 6\n};\n\n// time to wait for stdin before printing a warning\nvar stdinWarningTime = 5000;\nvar stdinWarningMessage = 'Hmmmmm... this is taking a long time. Your console is telling me to wait for input \\non stdin, but maybe that is not what you want.\\nTry specifying a package file explicitly with ' + chalk.blue('--packageFile package.json') + '. \\nSee https://github.com/tjunnone/npm-check-updates/issues/136#issuecomment-155721102';\n\n//\n// Helper functions\n//\n\nfunction print(options, message, loglevel, method) {\n\n    method = method || 'log';\n\n    // not in json mode\n    // not silent\n    // not at a loglevel under minimum specified\n    if (!options.json && options.loglevel !== 'silent' && (loglevel == null || logLevels[options.loglevel] >= logLevels[loglevel])) {\n        console[method](message);\n    }\n}\n\nfunction programError(options, message) {\n    if (options.cli) {\n        print(options, message, null, 'error');\n        process.exit(1);\n    } else {\n        throw new Error(message);\n    }\n}\n\nfunction printJson(options, message) {\n    if (options.loglevel !== 'silent') {\n        console.log(message);\n    }\n}\n\n/**\n * Gets the name of the package file based on --packageFile or --packageManager.\n */\nfunction getPackageFileName(options) {\n    return options.packageFile ? options.packageFile :\n        packageFileNames[options.packageManager];\n}\n\nfunction createDependencyTable() {\n    return new Table({\n        colAligns: ['left', 'right', 'right', 'right'],\n        chars: {\n            'top': '',\n            'top-mid': '',\n            'top-left': '',\n            'top-right': '',\n            'bottom': '',\n            'bottom-mid': '',\n            'bottom-left': '',\n            'bottom-right': '',\n            'left': '',\n            'left-mid': '',\n            'mid': '',\n            'mid-mid': '',\n            'right': '',\n            'right-mid': '',\n            'middle': ''\n        }\n    });\n}\n\n/**\n * @param args.from\n * @param args.to\n * @param options.greatest\n */\nfunction toDependencyTable(options, args) {\n\n    options = options || {};\n    var table = createDependencyTable();\n    var rows = Object.keys(args.to).map(function (dep) {\n        var from = args.from[dep] || '';\n        var to = versionUtil.colorizeDiff(args.to[dep] || '', args.from[dep]);\n        return [dep, from, 'â†’', to];\n    });\n    rows.forEach(function (row) {\n        table.push(row);\n    });\n    return table;\n}\n\nvar readPackageFile = cint.partialAt(fs.readFileAsync, 1, 'utf8');\nvar writePackageFile = fs.writeFileAsync;\n\n//\n// Main functions\n//\n\nfunction analyzeGlobalPackages(options) {\n\n    if (options.global && options.upgrade) {\n        programError(options, chalk.blue('ncu') + ' cannot upgrade global packages. Run ' + chalk.blue('npm install -g [package]') +\n            ' to update a global package');\n    }\n\n    print(options, 'Getting installed packages...', 'verbose');\n\n    return vm.getInstalledPackages({\n        filter: options.filter,\n        reject: options.reject\n    })\n        .then(function (globalPackages) {\n            print(options, globalPackages, 'silly');\n            print(options, '', 'silly');\n            print(options, 'Fetching ' + vm.getVersionTarget(options) + ' versions...', 'verbose');\n\n            return vm.upgradePackageDefinitions(globalPackages, options)\n                .spread(function (upgraded, latest) {\n\n                    print(options, latest, 'silly');\n                    printUpgrades(options, {\n                        current: globalPackages,\n                        upgraded: upgraded,\n                        latest: latest\n                    });\n\n                });\n        });\n}\n\nfunction analyzeProjectDependencies(options, pkgData, pkgFile) {\n\n    var pkg;\n\n    try {\n        pkg = jph.parse(pkgData);\n    } catch (e) {\n        programError(options, chalk.red('Invalid package file' + (pkgFile ? ': ' + pkgFile : ' from stdin') + '. Error details:\\n' + e.message));\n    }\n\n    var current = vm.getCurrentDependencies(pkg, {\n        prod: options.prod,\n        dev: options.dev,\n        optional: options.optional,\n        filter: options.filter,\n        reject: options.reject\n    });\n\n    print(options, 'Getting installed packages...', 'verbose');\n    print(options, 'Fetching ' + vm.getVersionTarget(options) + ' versions...', 'verbose');\n\n    return Promise.all([\n        current,\n        // only search for installed dependencies if a pkgFile is specified\n        pkgFile ? vm.getInstalledPackages({\n            cwd: options.packageFileDir ? path.dirname(path.resolve(pkgFile)) : null\n        }) : Promise.resolve(),\n        vm.upgradePackageDefinitions(current, options)\n    ])\n    .spread(function (current, installed, upgradedAndLatest) {\n\n        var output;\n        var newPkgData;\n\n        var upgraded = upgradedAndLatest[0];\n        var latest = upgradedAndLatest[1];\n\n        if (options.json) {\n            newPkgData = vm.upgradePackageData(pkgData, current, upgraded, latest, options);\n            // don't need try-catch here because pkgData has already been parsed as valid JSON, and vm.upgradePackageData simply does a find-and-replace on that\n            output = options.jsonAll ? jph.parse(newPkgData) :\n                options.jsonDeps ?\n                    _.pick(jph.parse(newPkgData), 'dependencies', 'devDependencies', 'optionalDependencies') :\n                    upgraded;\n\n            printJson(options, JSON.stringify(output));\n            return output;\n        } else {\n            printUpgrades(options, {\n                installed: installed,\n                current: current,\n                upgraded: upgraded,\n                latest: latest,\n                pkgData: pkgData,\n                pkgFile: pkgFile,\n                isUpgrade: options.upgrade\n            });\n            return null;\n        }\n    });\n}\n\n// TODO: printUpgrades and analyzeProjectDependencies need to be refactored. They are tightly coupled and monolithic.\n/**\n * @param args.current\n * @param args.upgraded\n * @param args.installed (optional)\n * @param args.latest (optional)\n * @param args.pkgData\n * @param args.pkgFile (optional)\n * @param args.isUpgrade (optional)\n */\nfunction printUpgrades(options, args) {\n\n    // split the deps into satisfied and unsatisfied to display in two separate tables\n    var deps = Object.keys(args.upgraded);\n    var satisfied = cint.toObject(deps, function (dep) {\n        return cint.keyValue(dep, vm.isSatisfied(args.latest[dep], args.current[dep]));\n    });\n\n    var isSatisfied = _.propertyOf(satisfied);\n    var satisfiedUpgraded = cint.filterObject(args.upgraded, function (dep) {\n        return isSatisfied(dep) && (!args.latest || !args.installed || args.latest[dep] !== args.installed[dep]);\n    });\n    var unsatisfiedUpgraded = cint.filterObject(args.upgraded, cint.not(isSatisfied));\n    var numSatisfied =   Object.keys(satisfiedUpgraded).length;\n    var numUnsatisfied = Object.keys(unsatisfiedUpgraded).length;\n\n    print(options, '');\n\n    // print everything is up-to-date\n    if (numSatisfied === 0 && numUnsatisfied === 0) {\n        var smiley = chalk.green.bold(':)');\n        if (options.global) {\n            print(options, 'All global packages are up-to-date ' + smiley);\n        } else {\n            print(options, 'All dependencies match the ' + vm.getVersionTarget(options) + ' package versions ' +\n                smiley);\n        }\n    }\n\n    // print unsatisfied table\n    if (numUnsatisfied > 0) {\n        var unsatisfiedTable = toDependencyTable(options, {\n            from: args.current,\n            to: unsatisfiedUpgraded\n        }, {\n            greatest: options.greatest,\n            newest: options.newest\n        });\n        print(options, unsatisfiedTable.toString());\n    }\n\n    // print satisfied table\n    if (numSatisfied > 0) {\n        var satisfiedTable = toDependencyTable(options, {\n            from: args.current,\n            to: satisfiedUpgraded\n        }, {\n            greatest: options.greatest,\n            newest: options.newest\n        });\n        print(options, (numUnsatisfied > 0 ? '\\n' : '') + 'The following dependenc' + (numSatisfied === 1 ? 'y is' : 'ies are') + ' satisfied by ' + (numSatisfied === 1 ? 'its' : 'their') + ' declared version range, but the installed version' + (numSatisfied === 1 ? ' is' : 's are') + ' behind. You can install the latest version' + (numSatisfied === 1 ? '' : 's') + ' without modifying your package file by using ' + chalk.blue(options.packageManager + ' update') + '. If you want to update the dependenc' + (numSatisfied === 1 ? 'y' : 'ies') + ' in your package file anyway, run ' + chalk.blue('ncu -a') + '.\\n', 'warn');\n        print(options, satisfiedTable.toString(), 'warn');\n    }\n\n    var numToUpgrade = numUnsatisfied + (options.upgradeAll ? numSatisfied : 0);\n\n    if (args.pkgFile && numToUpgrade > 0) {\n        if (options.errorLevel >= 2) {\n            programError(options, 'Dependencies not up-to-date');\n        } else if (args.isUpgrade) {\n            var newPkgData = vm.upgradePackageData(args.pkgData, args.current, args.upgraded, args.latest, options);\n            writePackageFile(args.pkgFile, newPkgData)\n                .then(function () {\n                    print(options, 'Upgraded ' + args.pkgFile + '\\n');\n                });\n        } else {\n            print(options, '\\nRun ' + chalk.blue('ncu') + ' with ' + chalk.blue(numUnsatisfied > 0 ? '-u' : '-a') + ' to upgrade ' + getPackageFileName(options));\n        }\n    }\n\n    print(options, '');\n}\n\n//\n// Program\n//\n\n\n/** Initializes and consolidates options from the cli. */\nfunction initOptions(options) {\n\n    return Object.assign({}, options, {\n        // 'upgradeAll' is a type of an upgrade so if it's set, we set 'upgrade' as well\n        upgrade: options.upgrade || options.upgradeAll,\n        // convert silent option to loglevel silent\n        loglevel: options.silent ? 'silent' : options.loglevel,\n        // add shortcut for any keys that start with 'json'\n        json: _(options)\n            .keys()\n            .filter(_.partial(_.startsWith, _, 'json', 0))\n            .some(_.propertyOf(options))\n    });\n}\n\n/** Finds the package file and data.\n    @returns Promise [pkgFile, pkgData]\n\nSearches as follows:\n --packageData flag\n --packageFile flag\n --stdin\n --findUp\n*/\nfunction findPackage(options) {\n\n    var pkgData;\n    var pkgFile;\n    var stdinTimer;\n\n    print(options, 'Running in local mode...', 'verbose');\n    print(options, 'Finding package file data...', 'verbose');\n\n    var pkgFileName = getPackageFileName(options);\n\n    /*\n\n     // if pkgFile was set, make sure it exists and read it into pkgData\n     if (pkgFile) {\n     // print a message if we are using a descendant package file\n     var relPathToPackage = path.resolve(pkgFile);\n     if (relPathToPackage !== pkgFileName) {\n     print(options, 'Using ' + relPathToPackage);\n     }\n     if (!fs.existsSync(pkgFile)) {\n     programError(options, chalk.red(relPathToPackage + ' not found'));\n     }\n\n     pkgData = readPackageFile(pkgFile, null, false);\n     }\n\n     // no package data!\n     if (!pkgData) {\n     }\n\n     return pkgData.then(_.partial(analyzeProjectDependencies, options, _, pkgFile));\n\n     */\n\n    function getPackageDataFromFile(pkgFile, pkgFileName) {\n        // exit if no pkgFile to read from fs\n        if (pkgFile !== null) {\n            // print a message if we are using a descendant package file\n            var relPathToPackage = path.resolve(pkgFile);\n            if (relPathToPackage !== pkgFileName) {\n                print(options, 'Using ' + relPathToPackage);\n            }\n        } else {\n            programError(options, chalk.red('No ' + pkgFileName) + '\\n\\nPlease add a ' + pkgFileName + ' to the current directory, specify the ' + chalk.blue('--packageFile') + ' or ' + chalk.blue('--packageData') + ' options, or pipe a ' + pkgFileName + ' to stdin.');\n        }\n\n        return readPackageFile(pkgFile);\n    }\n\n    // get the package data from the various input possibilities\n    if (options.packageData) {\n        pkgData = Promise.resolve(options.packageData);\n    } else if (options.packageFile) {\n        pkgFile = options.packageFile;\n        pkgData = getPackageDataFromFile(pkgFile, pkgFileName);\n    } else if (!process.stdin.isTTY) {\n        print(options, 'Waiting for package data on stdin...', 'verbose');\n\n        // warn the user after a while if still waiting for stdin\n        // this is a way to mitigate #136 where Windows unexpectedly waits for stdin\n        stdinTimer = setTimeout(function () {\n            console.log(stdinWarningMessage);\n        }, stdinWarningTime);\n\n        // clear the warning timer once stdin returns and fallback to scanning pwd if no content from stdin\n        pkgData = getstdin().then(function (_pkgData) {\n            clearTimeout(stdinTimer);\n\n            var isEmptyStdin = _pkgData.length === 0 || (_pkgData.length === 1 && _pkgData.charCodeAt(0) === 10);\n            // if no stdin content fall back to searching for package.json from pwd and up to root\n            if (isEmptyStdin) {\n                pkgFile = findUp.sync(pkgFileName);\n                return getPackageDataFromFile(pkgFile, pkgFileName);\n            } else {\n                return _pkgData;\n            }\n        });\n    } else {\n        // find the closest package starting from the current working directory and going up to the root\n        pkgFile = findUp.sync(pkgFileName);\n        pkgData = getPackageDataFromFile(pkgFile, pkgFileName);\n    }\n\n    return Promise.all([pkgData, pkgFile]);\n}\n\n/** main entry point */\nfunction run(opts) {\n    var options = opts || {};\n\n    // if not executed on the command-line (i.e. executed as a node module), set some defaults\n    if (!options.cli) {\n        options = _.defaults({}, options, {\n            // if they want to modify the package file, we must disable jsonUpgraded\n            // otherwise the write operation will not happen\n            jsonUpgraded: !options.upgrade,\n            // should not suggest upgrades to versions within the specified version range if upgradeAll is explicitly set to false. Will become the default in the next major version.\n            upgradeAll: options.upgradeAll === undefined ? true : options.upgradeAll,\n            loglevel: 'silent',\n            args: []\n        });\n    }\n\n    // get filter from arguments\n    options.filter = options.args.join(' ') || options.filter;\n\n    print(options, 'Initializing...', 'verbose');\n\n    return vm.initialize({\n        global: options.global,\n        packageManager: options.packageManager,\n        registry: options.registry\n    })\n    .then(function () {\n\n        options = initOptions(options);\n\n        if (options.timeout) {\n            var timeoutMs = _.isString(options.timeout) ? parseInt(options.timeout, 10) : options.timeout;\n            var timeout = setTimeout(function () {\n                programError(options, chalk.red('Exceeded global timeout of ' + timeoutMs + 'ms'));\n            }, timeoutMs);\n        }\n\n        var pendingAnalysis = options.global ?\n            analyzeGlobalPackages(options) :\n            findPackage(options).spread(_.partial(analyzeProjectDependencies, options));\n\n        if (timeout) {\n            pendingAnalysis = pendingAnalysis.then(function () {\n                clearTimeout(timeout);\n            });\n        }\n\n        return pendingAnalysis;\n    });\n}\n\nmodule.exports = Object.assign({\n    run: run\n}, vm);\n","/home/travis/build/npmtest/node-npmtest-npm-check-updates/node_modules/npm-check-updates/lib/versionmanager.js":"var semver = require('semver');\nvar _ = require('lodash');\nvar cint = require('cint');\nvar semverutils = require('semver-utils');\nvar Promise = require('bluebird');\nvar versionUtil = require('./version-util.js');\nvar requireDir = require('require-dir');\nvar packageManagers = requireDir('./package-managers');\n\n// keep order for setPrecision\nvar DEFAULT_WILDCARD = '^';\n\n/** Returns 'v' if the string starts with a v, otherwise returns empty string. */\nfunction v(str) {\n    return str && (str[0] === 'v' || str[1] === 'v') ? 'v' : '';\n}\n\n/** Returns a new function that AND's the two functions over the provided arguments. */\nfunction and(f, g) {\n    return function () {\n        return f.apply(this, arguments) && g.apply(this, arguments);\n    };\n}\n\n// set during initialize based on packageManagers[options.packageManager]\nvar selectedPackageManager;\n\n/**\n * Upgrade an existing dependency declaration to satisfy the latest version\n * @param declaration Current version declaration (e.g. \"1.2.x\")\n * @param latestVersion Latest version (e.g \"1.3.2\")\n * @returns {string} The upgraded dependency declaration (e.g. \"1.3.x\")\n */\nfunction upgradeDependencyDeclaration(declaration, latestVersion, options) {\n\n    options = options || {};\n    options.wildcard = options.wildcard || DEFAULT_WILDCARD;\n\n    // parse the latestVersion\n    // return original declaration if latestSemver is invalid\n    var latestSemver = semverutils.parseRange(latestVersion)[0];\n    if (!latestSemver) {\n        return declaration;\n    }\n\n    // return global versionUtil.wildcards immediately\n    if (options.removeRange) {\n        return latestVersion;\n    } else if (versionUtil.isWildCard(declaration)) {\n        return declaration;\n    }\n\n    // parse the declaration\n    // if multiple ranges, use the semver with the least number of parts\n    var parsedRange = _(semverutils.parseRange(declaration))\n        // semver-utils includes empty entries for the || and - operators. We can remove them completely\n        .reject({operator: '||'})\n        .reject({operator: '-'})\n        .sortBy(_.ary(_.flow(versionUtil.stringify, versionUtil.numParts), 1))\n        .value();\n    var declaredSemver = parsedRange[0];\n\n    /**\n     * Chooses version parts between the declared version and the latest.\n     * Base parts (major, minor, patch) are only included if they are in the original declaration.\n     * Added parts (release, build) are always included. They are only present if we are checking --greatest versions\n     * anyway.\n    */\n    function chooseVersion(part) {\n        return versionUtil.isWildPart(declaredSemver[part]) ? declaredSemver[part] :\n            _.includes(versionUtil.VERSION_BASE_PARTS, part) && declaredSemver[part] ? latestSemver[part] :\n            _.includes(versionUtil.VERSION_ADDED_PARTS, part) ? latestSemver[part] :\n            undefined;\n    }\n\n    // create a new semver object with major, minor, patch, build, and release parts\n    var newSemver = cint.toObject(versionUtil.VERSION_PARTS, function (part) {\n        return cint.keyValue(part, chooseVersion(part));\n    });\n    var newSemverString = versionUtil.stringify(newSemver);\n    var version = v(declaredSemver.semver) + newSemverString;\n\n    // determine the operator\n    // do not compact, because [undefined, '<'] must be differentiated from ['<']\n    var uniqueOperators = _(parsedRange)\n        .map(function (range) {\n            return range.operator;\n        })\n        .uniq()\n        .value();\n    var operator = uniqueOperators[0] || '';\n\n    var hasWildCard = versionUtil.WILDCARDS.some(_.partial(_.includes, newSemverString, _, 0));\n    var isLessThan = uniqueOperators[0] === '<' || uniqueOperators[0] === '<=';\n    var isMixed = uniqueOperators.length > 1;\n\n    // convert versions with </<= or mixed operators into the preferred wildcard\n    // only do so if the new version does not already contain a wildcard\n    return !hasWildCard && (isLessThan || isMixed) ?\n        versionUtil.addWildCard(version, options.wildcard) :\n        operator + version;\n}\n\n/**\n * Upgrade a dependencies collection based on latest available versions\n * @param currentDependencies current dependencies collection object\n * @param latestVersions latest available versions collection object\n * @returns {{}} upgraded dependency collection object\n */\nfunction upgradeDependencies(currentDependencies, latestVersions, options) {\n\n    options = options || {};\n\n    // filter out dependencies with empty values\n    currentDependencies = cint.filterObject(currentDependencies, function (key, value) {\n        return value;\n    });\n\n    // get the preferred wildcard and bind it to upgradeDependencyDeclaration\n    var wildcard = getPreferredWildcard(currentDependencies) || DEFAULT_WILDCARD;\n    var upgradeDep = _.partialRight(upgradeDependencyDeclaration, {\n        wildcard: wildcard,\n        removeRange: options.removeRange\n    });\n\n    return _(currentDependencies)\n        // only include packages for which a latest version was fetched\n        .pickBy(function (current, packageName) {\n            return packageName in latestVersions;\n        })\n        // combine the current and latest dependency objects into a single object keyed by packageName and containing\n        // both versions in an array: [current, latest]\n        .mapValues(function (current, packageName) {\n            var latest = latestVersions[packageName];\n            return [current, latest];\n        })\n        // pick the packages that are upgradeable\n        // we can use spread because isUpgradeable and upgradeDependencyDeclaration both take current and latest as\n        // arguments\n        .pickBy(_.spread(isUpgradeable))\n        .mapValues(_.spread(upgradeDep))\n        .value();\n}\n\n// Determines if the given version (range) should be upgraded to the latest (i.e. it is valid, it does not currently\n// satisfy the latest, and it is not beyond the latest)\nfunction isUpgradeable(current, latest) {\n\n    // do not upgrade non-npm version declarations (such as git tags)\n    // do not upgrade versionUtil.wildcards\n    if (!semver.validRange(current) || versionUtil.isWildCard(current)) {\n        return false;\n    }\n\n    // remove the constraint (e.g. ^1.0.1 -> 1.0.1) to allow upgrades that satisfy the range, but are out of date\n    var range = semverutils.parseRange(current)[0];\n    if (!range) {\n        throw new Error('\"' + current + '\" could not be parsed by semver-utils. This is probably a bug. Please file an issue at https://github.com/tjunnone/npm-check-updates.');\n    }\n    var version = versionUtil.stringify(range);\n\n    // make sure it is a valid range\n    // not upgradeable if the latest version satisfies the current range\n    // not upgradeable if the specified version is newer than the latest (indicating a prerelease version)\n    return Boolean(semver.validRange(version)) &&\n        !isSatisfied(latest, version) &&\n        !semver.ltr(latest, version);\n}\n\n// Return true if the version satisfies the range\nvar isSatisfied = semver.satisfies;\n\n/**\n * Creates a filter function from a given filter string. Supports strings, comma-or-space-delimited lists, and regexes.\n */\nfunction packageNameFilter(filter) {\n\n    var filterPackages;\n\n    // no filter\n    if (!filter) {\n        filterPackages = _.identity;\n    } else if (typeof filter === 'string') {\n        // RegExp filter\n        if (filter[0] === '/' && cint.index(filter,-1) === '/') {\n            var regexp = new RegExp(filter.slice(1, filter.length-1));\n            filterPackages = regexp.test.bind(regexp);\n        } else {\n            // string filter\n            var packages = filter.split(/[\\s,]+/);\n            filterPackages = _.includes.bind(_, packages);\n        }\n    } else if (Array.isArray(filter)) {\n        // array filter\n        filterPackages = _.includes.bind(_, filter);\n    } else if (filter instanceof RegExp) {\n        // raw RegExp\n        filterPackages = filter.test.bind(filter);\n    } else {\n        throw new Error('Invalid packages filter. Must be a RegExp, array, or comma-or-space-delimited list.');\n    }\n\n    // (limit the arity to 1 to avoid passing the value)\n    return cint.aritize(filterPackages, 1);\n}\n\n/** Creates a single filter function from an optional filter and optional reject. */\nfunction filterAndReject(filter, reject) {\n    return and(\n        filter ? packageNameFilter(filter) : _.identity,\n        reject ? _.negate(packageNameFilter(reject)) : _.identity\n    );\n}\n\nfunction upgradePackageDefinitions(currentDependencies, options) {\n    var versionTarget = getVersionTarget(options);\n\n    return queryVersions(currentDependencies, {\n        versionTarget: versionTarget,\n        registry: options.registry ? options.registry : null\n    }).then(function (latestVersions) {\n\n        var upgradedDependencies = upgradeDependencies(currentDependencies, latestVersions, {\n            removeRange: options.removeRange\n        });\n\n        var filteredUpgradedDependencies = _.pickBy(upgradedDependencies, function (v, dep) {\n            return !options.jsonUpgraded || options.upgradeAll || !isSatisfied(latestVersions[dep], currentDependencies[dep]);\n        });\n\n        return [filteredUpgradedDependencies, latestVersions];\n    });\n}\n\n/**\n * Upgrade the dependency declarations in the package data\n * @param pkgData The package.json data, as utf8 text\n * @param oldDependencies Object of old dependencies {package: range}\n * @param newDependencies Object of new dependencies {package: range}\n * @param newVersions Object of new versions {package: version}\n * @returns {string} The updated package data, as utf8 text\n */\nfunction upgradePackageData(pkgData, oldDependencies, newDependencies, newVersions, options) {\n\n    options = options || {};\n\n    for (var dependency in newDependencies) {\n        if (options.upgradeAll || !isSatisfied(newVersions[dependency], oldDependencies[dependency])) {\n            var expression = '\"' + dependency + '\"\\\\s*:\\\\s*\"' + escapeRegexp(oldDependencies[dependency] + '\"');\n            var regExp = new RegExp(expression, 'g');\n            pkgData = pkgData.replace(regExp, '\"' + dependency + '\": ' + '\"' + newDependencies[dependency] + '\"');\n        }\n    }\n\n    return pkgData;\n}\n\n/**\n * Get the current dependencies from the package file\n * @param pkgData Object with dependencies, devDependencies, and/or optionalDependencies properties\n * @param options.dev\n * @param options.filter\n * @param options.prod\n * @param options.reject\n * @returns Promised {packageName: version} collection\n */\nfunction getCurrentDependencies(pkgData, options) {\n\n    pkgData = pkgData || {};\n    options = options || {};\n\n    if (!options.prod && !options.dev && !options.optional) {\n        options.prod = options.dev = options.optional = true;\n    }\n\n    var allDependencies = cint.filterObject(_.merge({},\n        options.prod && pkgData.dependencies,\n        options.dev && pkgData.devDependencies,\n        options.optional && pkgData.optionalDependencies\n    ), filterAndReject(options.filter, options.reject));\n\n    return allDependencies;\n}\n\n/**\n * @options.cwd\n */\nfunction getInstalledPackages(options) {\n\n    options = options || {};\n\n    return selectedPackageManager.list([], {cwd: options.cwd}).then(function (results) {\n        if (!results || !results.dependencies) {\n            throw new Error('Unable to retrieve NPM package list');\n        }\n\n        // filter out undefined packages or those with a wildcard\n        var filterFunction = filterAndReject(options.filter, options.reject);\n        var validPackages = cint.filterObject(results.dependencies, function (dep, pkgInfo) {\n            return pkgInfo && pkgInfo.name && pkgInfo.version && !versionUtil.isWildPart(pkgInfo.version) && filterFunction(dep);\n        });\n\n        // convert the dependency object from npm into a simple object that maps the package name to its version\n        var simpleDependencies = cint.mapObject(validPackages, function (dep, pkgInfo) {\n            return cint.keyValue(dep, pkgInfo.version);\n        });\n\n        return simpleDependencies;\n    });\n}\n\n/**\n * Get the latest or greatest versions from the NPM repository based on the version target\n * @param packageMap   an object whose keys are package name and values are current versions\n * @param options       Options. Default: { versionTarget: 'latest' }. You may also specify { versionTarge: 'greatest' }\n * @returns             Promised {packageName: version} collection\n */\nfunction queryVersions(packageMap, options) {\n\n    var getPackageVersion;\n    options = options || {};\n\n    var packageList = Object.keys(packageMap);\n\n    // validate options.versionTarget\n    options.versionTarget = options.versionTarget || 'latest';\n\n    // determine the getPackageVersion function from options.versionTarget\n    switch (options.versionTarget) {\n        case 'latest':\n            getPackageVersion = selectedPackageManager.latest;\n            break;\n        case 'greatest':\n            getPackageVersion = selectedPackageManager.greatest;\n            break;\n        case 'newest':\n            getPackageVersion = selectedPackageManager.newest;\n            break;\n        case 'major':\n            getPackageVersion = selectedPackageManager.greatestMajor;\n            break;\n        case 'minor':\n            getPackageVersion = selectedPackageManager.greatestMinor;\n            break;\n        default:\n            var supportedVersionTargets = ['latest', 'newest', 'greatest', 'major', 'minor'];\n            return Promise.reject(new Error('Unsupported versionTarget: ' + options.versionTarget +\n                '. Supported version targets are: ' + supportedVersionTargets.join(', ')));\n    }\n\n    // ignore 404 errors from getPackageVersion by having them return null instead of rejecting\n    function getPackageVersionProtected(dep) {\n        return getPackageVersion(dep, packageMap[dep]).catch(function (err) {\n            if (err.message == 404) { // eslint-disable-line eqeqeq\n                return null;\n            } else {\n                throw err;\n            }\n        });\n    }\n\n    // zip up the array of versions into to a nicer object keyed by package name\n    function zipVersions(versionList) {\n        return cint.toObject(versionList, function (version, i) {\n            return cint.keyValue(packageList[i], version);\n        });\n    }\n\n    return Promise.map(packageList, getPackageVersionProtected)\n        .then(zipVersions)\n        .then(_.partialRight(_.pickBy, _.identity));\n}\n\n/**\n * Given a dependencies collection, returns whether the user prefers ^, ~, .*, or .x (simply counts the greatest number\n * of occurrences). Returns null if given no dependencies.\n */\nfunction getPreferredWildcard(dependencies) {\n\n    // if there are no dependencies, return null.\n    if (Object.keys(dependencies).length === 0) {\n        return null;\n    }\n\n    // group the dependencies by wildcard\n    var groups = _.groupBy(_.values(dependencies), function (dep) {\n        return _.find(versionUtil.WILDCARDS, function (wildcard) {\n            return dep && dep.indexOf(wildcard) > -1;\n        });\n    });\n\n    // if none of the dependencies use a wildcard, return null\n    var usedWildcards = Object.keys(groups);\n    if (usedWildcards.length === 1 && usedWildcards[0] === 'undefined') {\n        return null;\n    }\n\n    // convert to an array of objects that can be sorted\n    var arrOfGroups = cint.toArray(groups, function (wildcard, instances) {\n        return {\n            wildcard: wildcard,\n            instances: instances\n        };\n    });\n\n    // reverse sort the groups so that the wildcard with the most appearances is at the head, then return it.\n    var sorted = _.sortBy(arrOfGroups, function (wildcardObject) {\n        return -wildcardObject.instances.length;\n    });\n\n    return sorted[0].wildcard;\n}\n\nfunction getVersionTarget(options) {\n    return options.semverLevel ? options.semverLevel :\n        options.newest ? 'newest' :\n        options.greatest ? 'greatest' :\n        'latest';\n}\n\n/**\n * Initialize the version manager with the given package manager.\n * @param args.global\n * @param args.packageManager\n */\nfunction initialize(args) {\n\n    args = args || {};\n    args.packageManager = args.packageManager || 'npm';\n\n    if (!(args.packageManager in packageManagers)) {\n        throw new Error('Invalid package manager: ' + args.packageManager);\n    }\n\n    selectedPackageManager = packageManagers[args.packageManager];\n\n    return selectedPackageManager.init({\n        global: args.global,\n        registry: args.registry\n    });\n}\n\n//\n// Helper functions\n//\n\nfunction escapeRegexp(s) {\n    return s.replace(/[-\\/\\\\^$*+?.()|[\\]{}]/g, '\\\\$&'); // Thanks Stack Overflow!\n}\n\n//\n// API\n//\n\nmodule.exports = {\n    initialize: initialize,\n    upgradeDependencyDeclaration: upgradeDependencyDeclaration,\n    upgradePackageData: upgradePackageData,\n    upgradePackageDefinitions: upgradePackageDefinitions,\n    getCurrentDependencies: getCurrentDependencies,\n    upgradeDependencies: upgradeDependencies,\n    getInstalledPackages: getInstalledPackages,\n    queryVersions: queryVersions,\n    isUpgradeable: isUpgradeable,\n    isSatisfied: isSatisfied,\n    getPreferredWildcard: getPreferredWildcard,\n    getVersionTarget: getVersionTarget,\n    // deprecate in next major version\n    getLatestPackageVersion: function (pkgData) {\n        return selectedPackageManager.latest(pkgData);\n    },\n    getGreatestPackageVersion: function (pkgData) {\n        return selectedPackageManager.greatest(pkgData);\n    }\n};\n","/home/travis/build/npmtest/node-npmtest-npm-check-updates/node_modules/npm-check-updates/lib/version-util.js":"var semverutils = require('semver-utils');\nvar _ = require('lodash');\nvar chalk = require('chalk');\nvar util = require('util');\n\nvar VERSION_BASE_PARTS = ['major', 'minor', 'patch'];\nvar VERSION_ADDED_PARTS = ['release', 'build'];\nvar VERSION_PARTS = [].concat(VERSION_BASE_PARTS, VERSION_ADDED_PARTS);\nvar VERSION_PART_DELIM = {\n    major: '',\n    minor: '.',\n    patch: '.',\n    release: '-',\n    build: '+'\n};\nvar WILDCARDS = ['^', '~', '.*', '.x'];\nvar WILDCARDS_PURE = ['^', '~', '^*', '*', 'x', 'x.x', 'x.x.x'];\nvar WILDCARD_PURE_REGEX = new RegExp('^(' + WILDCARDS_PURE.join('|')\n    .replace(/\\^/g, '\\\\^')\n    .replace(/\\*/g, '\\\\*') + ')$');\nvar SEMANTIC_DIRECT = new RegExp('^\\\\d+\\\\.\\\\d+\\\\.\\\\d+([-|+].*)*$');\n\n/**\n * Returns the number of parts in the version\n */\nfunction numParts(version) {\n\n    var semver = semverutils.parseRange(version)[0];\n\n    if (!semver) {\n        throw new Error(util.format('semverutils.parseRange returned null when trying to parse \"%s\". This is probably a problem with the \"semver-utils\" dependency. Please report an issue at https://github.com/tjunnone/npm-check-updates/issues.', version));\n    }\n\n    return _.intersection(VERSION_PARTS, Object.keys(semver)).length;\n}\n\n/**\n * Increases or decreases the given precision by the given amount, e.g. major+1 -> minor\n */\nfunction precisionAdd(precision, n) {\n\n    if (n === 0) {\n        return precision;\n    }\n\n    var index = n === 0 ? precision :\n        _.includes(VERSION_BASE_PARTS, precision) ? VERSION_BASE_PARTS.indexOf(precision) + n :\n        _.includes(VERSION_ADDED_PARTS, precision) ? VERSION_BASE_PARTS.length + n :\n        null;\n\n    if (index === null) {\n        throw new Error('Invalid precision: ' + precision);\n    } else if (!VERSION_PARTS[index]) {\n        throw new Error('Invalid precision math' + arguments);\n    }\n\n    return VERSION_PARTS[index];\n}\n\n/** Joins the major, minor, patch, release, and build parts (controlled by an optional precision arg) of a semver object\n * into a dot-delimited string. */\nfunction stringify(semver, precision) {\n\n    // get a list of the parts up until (and including) the given precision\n    // or all of them, if no precision is specified\n    var parts = precision ? VERSION_PARTS.slice(0, VERSION_PARTS.indexOf(precision)+1) : VERSION_PARTS;\n\n    // pair each part with its delimiter and join together\n    return parts\n        .filter(function (part) {\n            return _.includes(VERSION_BASE_PARTS, precision) || semver[part];\n        })\n        .map(function (part) {\n            return VERSION_PART_DELIM[part] + (semver[part] || '0');\n        })\n        .join('');\n}\n\n/**\n * Gets how precise this version number is (major, minor, patch, release, or build)\n */\nfunction getPrecision(version) {\n    var semver = semverutils.parseRange(version)[0];\n    // expects VERSION_PARTS to be in correct order\n    return _.find(VERSION_PARTS.slice().reverse(), _.propertyOf(semver));\n}\n\n/**\n * Sets the precision of a (loose) semver to the specified level: major, minor, etc.\n */\nfunction setPrecision(version, precision) {\n    var semver = semverutils.parseRange(version)[0];\n    return stringify(semver, precision);\n}\n\n/** Adds a given wildcard (^,~,.*,.x) to a version number. Adds ^ and ~ to the beginning. Replaces everything after the\n * major version number with .* or .x */\nfunction addWildCard(version, wildcard) {\n    return wildcard === '^' || wildcard === '~' ?\n        wildcard + version :\n        setPrecision(version, 'major') + wildcard;\n}\n\n/** Returns true if the given string is one of the wild cards. */\nfunction isWildCard(version) {\n    return WILDCARD_PURE_REGEX.test(version);\n}\n\n/** Returns true if the given digit is a wildcard for a part of a version. */\nfunction isWildPart(versionPart) {\n    return versionPart === '*' || versionPart === 'x';\n}\n\n/**\n * Colorize the parts of a version string that are different than a given string to compare to. Assumes that the two\n * verson strings are in the same format.\n */\nfunction colorizeDiff(strToColor, strToCompare, options) {\n\n    options = options || {};\n    options.color = options.color || 'green';\n    var leadingWildcard = '';\n\n    // separate out leading ^ or ~\n    if (/^[~^]/.test(strToColor) && strToColor[0] === strToCompare[0]) {\n        leadingWildcard = strToColor[0];\n        strToColor = strToColor.slice(1);\n        strToCompare = strToCompare.slice(1);\n    }\n\n    // split into parts\n    var partsToColor = strToColor.split('.');\n    var partsToCompare = strToCompare.split('.');\n\n    var i = _.findIndex(partsToColor, function (part, i) {\n        return part !== partsToCompare[i];\n    });\n    i = i >= 0 ? i : partsToColor.length;\n\n    // if we are colorizing only part of the word, add a dot in the middle\n    var middot = i > 0 && i < partsToColor.length ? '.' : '';\n\n    return leadingWildcard +\n        partsToColor.slice(0,i).join('.') +\n        middot +\n        chalk[options.color](partsToColor.slice(i).join('.'));\n}\n\n/**\n * @param versions  Array of all available versions\n * @param current   Current version\n * @param level     major/minor\n * @Returns         String representation of the suggested version. If the current version\n * is not direct then returns null\n */\nfunction findGreatestByLevel(versions, current, level) {\n    if (!SEMANTIC_DIRECT.test(current)) {\n        return null;\n    }\n\n    var cur = semverutils.parse(current);\n    return _.chain(versions)\n        .map(function (v) {\n            return {\n                string: v,\n                parsed: semverutils.parse(v)\n            };\n        })\n        .filter(function (o) {\n            if (level === 'minor' && o.parsed.major !== cur.major) {\n                return false;\n            }\n            return o.parsed[level] === cur[level];\n        })\n        .map(function (o) {\n            return o.string;\n        })\n        .last()\n        .value();\n}\n\nmodule.exports = {\n    numParts: numParts,\n    stringify: stringify,\n    precisionAdd: precisionAdd,\n    getPrecision: getPrecision,\n    setPrecision: setPrecision,\n    addWildCard: addWildCard,\n    isWildCard: isWildCard,\n    isWildPart: isWildPart,\n    colorizeDiff: colorizeDiff,\n    findGreatestByLevel: findGreatestByLevel,\n    VERSION_BASE_PARTS: VERSION_BASE_PARTS,\n    VERSION_ADDED_PARTS: VERSION_ADDED_PARTS,\n    VERSION_PARTS: VERSION_PARTS,\n    WILDCARDS: WILDCARDS\n};\n","/home/travis/build/npmtest/node-npmtest-npm-check-updates/node_modules/npm-check-updates/lib/package-managers/bower.js":"var cint = require('cint');\nvar Promise = require('bluebird');\nvar npmi = Promise.promisify(require('npmi'));\nvar pkg = require('../../package.json');\nvar bower; // installed on-demand using npmi\n\nmodule.exports = {\n\n    /**\n     * @param args.global\n     * @param args.registry\n     * @param args.loglevel\n     */\n    init: function (args) {\n\n        args = args || {};\n\n        var installed; // I promise bower is installed\n\n        // see if the bower dependency has been installed\n        try {\n            require.resolve('bower'); // throws an error if not installed\n            installed = Promise.resolve();\n        } catch (e) {\n            if (args.loglevel !== 'silent') {\n                console.log('Installing bower dependency... (this is a one-time operation)');\n            }\n\n            // install bower on-demand\n            installed = npmi({\n                name: 'bower',\n                version: pkg.dynamicDependencies.bower,\n                path: __dirname + '/../../'\n            });\n        }\n\n        return installed.then(function () {\n            bower = require('bower');\n        });\n    },\n\n    list: function () {\n        return new Promise(function (resolve, reject) {\n            bower.commands.list()\n                .on('end', function (results) {\n                    // massage results (move pkgMeta up a level) to match expected interface (see ./README.md)\n                    resolve({\n                        dependencies: cint.mapObject(results.dependencies, function (key, value) {\n                            return cint.keyValue(key, value.pkgMeta);\n                        })\n                    });\n                })\n                .on('error', reject);\n        });\n    },\n\n    latest: function (packageName) {\n\n        return new Promise(function (resolve, reject) {\n            bower.commands.info(packageName)\n                .on('end', function (results) {\n                    resolve(results.latest.version);\n                })\n                .on('error', function (err) {\n                    // normalize 404\n                    reject(/Package \\S* not found/.test(err.message) ? new Error(404) : err);\n                });\n        });\n    },\n\n    greatest: function (packageName) {\n\n        return new Promise(function (resolve, reject) {\n            bower.commands.info(packageName)\n                .on('end', function (results) {\n                    resolve(results.versions[0]); // bower versions returned in highest-to-lowest order.\n                })\n                .on('error', reject);\n        });\n    },\n\n    newest: function () {\n        throw new Error('Semantic versioning level \"newest\" is not supported for Bower');\n    },\n\n    greatestMajor: function () {\n        throw new Error('Semantic versioning level \"major\" is not supported for Bower');\n    },\n\n    greatestMinor: function () {\n        throw new Error('Semantic versioning level \"minor\" is not supported for Bower');\n    }\n};\n","/home/travis/build/npmtest/node-npmtest-npm-check-updates/node_modules/npm-check-updates/bin/npm-check-updates":"#!/usr/bin/env node\nrequire('node-alias')('ncu', __dirname);\n","/home/travis/build/npmtest/node-npmtest-npm-check-updates/node_modules/npm-check-updates/bin/ncu":"#!/usr/bin/env node\n\nvar program = require('commander');\nvar updateNotifier = require('update-notifier');\nvar cint = require('cint');\nvar ncu = require('../lib/npm-check-updates');\nvar pkg = require('../package.json');\n\n// check if a new version of ncu is available and print an update notification\nupdateNotifier({pkg: pkg})\n    .notify({defer: false});\n\nprogram\n    .description('[filter] is a list or regex of package names to check (all others will be ignored).')\n    .usage('[options] [filter]')\n    .option('-d, --dev', 'check only devDependencies')\n    .option('-e, --error-level <n>', 'set the error-level. 1: exits with error code 0 if no errors occur. 2: exits with error code 0 if no packages need updating (useful for continuous integration). Default is 1.', cint.partialAt(parseInt, 1, 10), 1)\n    .option('-f, --filter <matches>', 'include only package names matching the given string, comma-delimited list, or regex')\n    .option('-g, --global', 'check global packages instead of in the current project')\n    // program.json is set to true in programInit if any options that begin with 'json' are true\n    .option('-j, --jsonAll', 'output new package file instead of human-readable message')\n    .option('--jsonUpgraded', 'output upgraded dependencies in json')\n    .option('-l, --loglevel <n>', 'what level of logs to report: silent, error, minimal, warn, info, verbose, silly (default: warn)', 'warn')\n    .option('-m, --packageManager <name>', 'npm (default) or bower', 'npm')\n    .option('-n, --newest', 'find the newest versions available instead of the latest stable versions')\n    .option('-o, --optional', 'check only optionalDependencies')\n    .option('--packageData', 'include stringified package file (use stdin instead)')\n    .option('--packageFile <filename>', 'package file location (default: ./package.json)')\n    .option('--packageFileDir', 'use same directory as packageFile to compare against installed modules. See #201.')\n    .option('-p, --prod', 'check only dependencies (not devDependencies)')\n    .option('-r, --registry <url>', 'specify third-party npm registry')\n    .option('-s, --silent', \"don't output anything (--loglevel silent)\")\n    .option('-t, --greatest', 'find the highest versions available instead of the latest stable versions')\n    .option('--timeout <ms>', 'a global timeout in ms')\n    .option('-u, --upgrade', 'overwrite package file')\n    .option('-x, --reject <matches>', 'exclude packages matching the given string, comma-delimited list, or regex')\n    .option('-a, --upgradeAll', 'include even those dependencies whose latest version satisfies the declared semver dependency')\n    .option('--semverLevel <level>', 'find the highest version within \"major\" or \"minor\"')\n    .option('--removeRange', 'remove version ranges from the final package version')\n    .option('-v, --version', pkg.version, function() { console.log(pkg.version); process.exit(0); })\n    .option('-V', '', function() { console.log(pkg.version); process.exit(0); });\n\nprogram.parse(process.argv);\n\nprogram.cli = true;\nprogram.filter = program.args.join(' ') || program.filter;\n\nncu.run(program);\n","/home/travis/build/npmtest/node-npmtest-npm-check-updates/node_modules/npm-check-updates/lib/raw-promisify.js":"var _ = require('lodash');\nvar Promise = require('bluebird');\n\n/**\n * For some reason, Promise.promisifyAll does not work on npm.commands :(\n *   Promise.promisifyAll(npm.commands);\n * So we have to do it manually.\n */\nfunction rawPromisify(obj) {\n    _.each(obj, function (method, name) {\n        obj[name + 'Async'] = function () {\n            var args = [].slice.call(arguments);\n            var that = this;\n            return new Promise(function (resolve, reject) {\n                args.push(function (err, results) {\n                    if (err) {\n                        reject(err);\n                    } else {\n                        resolve(results);\n                    }\n                });\n                return method.apply(that, args);\n            });\n        };\n    });\n}\n\nmodule.exports = rawPromisify;\n","/home/travis/build/npmtest/node-npmtest-npm-check-updates/node_modules/npm-check-updates/lib/package-managers/npm.js":"var _ = require('lodash');\nvar cint = require('cint');\nvar Promise = require('bluebird');\nvar npm = Promise.promisifyAll(require('npm'));\nvar rawPromisify = require('../raw-promisify.js');\nvar versionUtil  = require('../version-util.js');\nvar spawn        = require('spawn-please');\n\nvar initialized = false;\n\n/**\n * @param packageName   Name of the package\n * @param field         Field such as \"versions\" or \"dist-tags.latest\" accepted by npm.commands.view (https://docs.npmjs.com/api/view)\n * @Returns             Promised result\n */\nfunction view(packageName, field) {\n    if (!initialized) {\n        throw new Error('init must be called before using the version manager');\n    }\n\n    return npm.commands.viewAsync([packageName, field], true)\n        .catch(function (err) {\n            // normalize 404 errors\n            throw err.statusCode === 404 ? new Error(404) : err;\n        })\n        .then(function (response) {\n\n            // rare case where npm view returns an empty response\n            // https://github.com/tjunnone/npm-check-updates/issues/162\n            if (_.isEmpty(response)) {\n                throw new Error(404);\n            }\n\n            return _.values(response)[0][field];\n        });\n}\n\nmodule.exports = {\n\n    /**\n     * @param args.global\n     * @param args.registry\n     * @param args.prefix\n     */\n    init: function (args) {\n\n        args = args || {};\n\n        // use pickBy to eliminate undefined values\n        return npm.loadAsync(_.pickBy({\n            silent: true,\n            global: args.global || undefined,\n            prefix: args.prefix || undefined\n        }, _.identity))\n        .then(function () {\n\n            // configure registry\n            if (args.registry) {\n                npm.config.set('registry', args.registry);\n            }\n\n            rawPromisify(npm.commands);\n\n            // FIX: for ncu -g doesn't work on homebrew or windows #146\n            // https://github.com/tjunnone/npm-check-updates/issues/146\n            if (args.global && npm.config.get('prefix').match('Cellar')) {\n                npm.config.set('prefix', '/usr/local');\n            }\n\n            // Workaround: set prefix on windows for global packages\n            // Only needed when using npm api directly\n            if (process.platform === 'win32' && npm.config.get('global') && !process.env.prefix) {\n                npm.config.set('prefix', process.env.AppData + '\\\\npm');\n            }\n\n            return initialized = true;\n        });\n    },\n\n    /**\n     * @args    Arguments for npm ls\n     * @options.cwd (optional)\n    */\n    list: function (args, options) {\n\n        options = options || {};\n\n        if (!initialized) {\n            throw new Error('init must be called before using the version manager');\n        }\n\n        // if packageFile is specified, spawn an npm process so that installed modules can be read from the same directotry as the package file (#201)\n        return options.cwd ?\n            spawn(process.platform === 'win32'? 'npm.cmd' : 'npm', ['ls', '--json', '-depth=0'], {cwd: options.cwd})\n                .then(JSON.parse)\n                // transform results into a similar format as the API\n                .then(function (results) {\n                    return {\n                        dependencies: cint.mapObject(results.dependencies, function (name, info) {\n                            return cint.keyValue(name, {\n                                name: name,\n                                version: info.version\n                            });\n                        })\n                    };\n                }) :\n            npm.commands.listAsync(args || [], true); // silent:true\n    },\n\n    latest: cint.partialAt(view, 1, 'dist-tags.latest'),\n\n    newest: function (packageName) {\n        return view(packageName, 'time')\n            .then(_.keys)\n            .then(_.last);\n    },\n\n    greatest: function (packageName) {\n        return view(packageName, 'versions').then(_.last);\n    },\n\n    greatestMajor: function (packageName, currentVersion) {\n        return view(packageName, 'versions').then(function (versions) {\n            return versionUtil.findGreatestByLevel(versions, currentVersion, 'major');\n        });\n    },\n    greatestMinor: function (packageName, currentVersion) {\n        return view(packageName, 'versions').then(function (versions) {\n            return versionUtil.findGreatestByLevel(versions, currentVersion, 'minor');\n        });\n    }\n};\n"}